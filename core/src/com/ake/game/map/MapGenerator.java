package com.ake.game.map;

import java.util.Arrays;
import java.util.Random;

import com.ake.game.libs.*;
import com.badlogic.gdx.graphics.Texture;
import com.badlogic.gdx.graphics.g2d.TextureRegion;
import com.badlogic.gdx.maps.tiled.TiledMap;
import com.badlogic.gdx.maps.tiled.TiledMapTileLayer;
import com.badlogic.gdx.maps.tiled.TiledMapTileSet;
import com.badlogic.gdx.maps.tiled.tiles.StaticTiledMapTile;
import com.badlogic.gdx.math.Vector2;
import com.badlogic.gdx.utils.Array;

class Node2 {
    private int x, y;
    private int value;

    Node2(int x, int y, int value) {
        this.x = x;
        this.y = y;
        this.value = value;
    }

    public int getX() {
        return x;
    }

    public void setX(int x) {
        this.x = x;
    }

    public int getY() {
        return y;
    }

    public void setY(int y) {
        this.y = y;
    }

    public int getValue() {
        return value;
    }

    public void setValue(int value) {
        this.value = value;
    }

    @Override
    public String toString() {
        return Integer.toString(this.value);
    }

}

public class MapGenerator {
    private final int GRASS_FULL = 14, ROCK_RIGHT = 15, ROCK_LEFT = 13, ROCK_TOP = 6, ROCK_BOTTOM = 22,
            ROCK_TOP_RIGHT = 7, ROCK_TOP_LEFT = 5, ROCK_BOTTOM_RIGHT = 23, ROCK_BOTTOM_LEFT = 21, ROCK_BOUNDED_LEFT = 1,
            ROCK_BOUNDED_RIGHT = 3, ROCK_BOUNDED_BOTTOM = 20, ROCK_BOUNDED_TOP = 4, BOUNDED_TOP_BOTTOM = 2,
            BOUNDED_LEFT_RIGHT = 12, ROCK_BOUNDED = 0, ROCK_FULL = 47;

    private final String filename = "tileset.png";
    private final int tileSize = 32;
    private final int MAP_COLS = 100; // 100 tiles horizontally
    private final int MAP_ROWS = 50; // 50 tiles vertically
    private final int MAP_WIDTH = tileSize * MAP_COLS; // X-axis resolution
    private final int MAP_HEIGHT = tileSize * MAP_ROWS; // Y-axis resolution

    private Array<Vector2> solid_objects;

    private TiledMap map;
    private int seed;
    private TiledMapTileLayer baseLayer;
    private TiledMapTileLayer obstacleLayer;
    private TiledMapTileLayer wallLayer;
    private TiledMapTileSet tileSet;
    private Texture tilesTexture;
    private float[][] noiseMap;
    private Node2[][] generatedMap;

    public int getTileSize() {
        return this.tileSize;
    }

    public int getMapWidth() {
        return this.MAP_WIDTH;
    }

    public int getMapHeight() {
        return this.MAP_HEIGHT;
    }

    public int getSeed() {
        return this.seed;
    }

    // https://math.stackexchange.com/questions/914823/shift-numbers-into-a-different-range
    private float mapOneRangeToAnother(float t, float a, float b, float c, float d) {
        return (c + ((d - c) / (b - a)) * (t - a));
    }

    MapGenerator(int seed) {
        this.map = null;
        this.seed = seed;
        // Noise Generator setup
        FastNoiseLite noise = new FastNoiseLite();
        noise.SetSeed(this.seed);
        noise.SetNoiseType(FastNoiseLite.NoiseType.Cellular);
        noise.SetFrequency(0.3f);
        noise.SetFractalType(FastNoiseLite.FractalType.Ridged);
        noise.SetFractalLacunarity(0.4f);
        noise.SetFractalGain(6.00f);
        noise.SetCellularDistanceFunction(FastNoiseLite.CellularDistanceFunction.Euclidean);
        noise.SetCellularReturnType(FastNoiseLite.CellularReturnType.Distance2Div);
        noise.SetCellularJitter(1f);

        // Creation of noise map
        this.noiseMap = new float[MAP_ROWS][MAP_COLS];

        // Filling the empty noise map with -1
        for (float[] row : this.noiseMap)
            Arrays.fill(row, -1f);

        Random random = new Random(this.seed);

        // Writing noise values generated by noise generator to specified cell
        int noOfCellsToLeave = 1;
        for (int i = noOfCellsToLeave; i < MAP_ROWS - noOfCellsToLeave; i++) {
            for (int j = noOfCellsToLeave; j < MAP_COLS - noOfCellsToLeave; j++) {
                this.noiseMap[i][j] = mapOneRangeToAnother(noise.GetNoise(i, j), -1f, 1f, 0f, 1f);
                this.noiseMap[i][MAP_COLS / 2] = 1;
                this.noiseMap[MAP_ROWS / 2][j] = 1;

                if (random.nextFloat() < 0.15f) {
                    this.noiseMap[MAP_ROWS / 2 - 1][j] = 1;
                    this.noiseMap[MAP_ROWS / 2 - 2][j] = 1;

                    this.noiseMap[i][MAP_COLS / 2 + 1] = 1;
                    this.noiseMap[i][MAP_COLS / 2 + 2] = 1;
                } else if (random.nextFloat() < 0.15f) {

                    this.noiseMap[MAP_ROWS / 2 + 1][j] = 1;
                    this.noiseMap[MAP_ROWS / 2 + 2][j] = 1;

                    this.noiseMap[i][MAP_COLS / 2 - 1] = 1;
                    this.noiseMap[i][MAP_COLS / 2 - 2] = 1;
                }
            }
        }

        this.solid_objects = new Array<>();

        this.createMap();
    }

    private void createMap() {
        // Iterate on map cells from bottom-left to top-right
        this.generatedMap = new Node2[MAP_ROWS][MAP_COLS];
        for (int row = 0; row < MAP_ROWS; row++) {
            for (int col = 0; col < MAP_COLS; col++) {
                this.generatedMap[row][col] = new Node2(row, col, pickTile(row, col));
            }
        }
    }

    private Node2 getLeft(int x, int y) {
        try {
            Node2 node = this.generatedMap[x][y + 1];
            return node;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    private Node2 getRight(int x, int y) {
        try {
            Node2 node = this.generatedMap[x][y - 1];
            return node;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    private Node2 getTop(int x, int y) {
        try {
            Node2 node = this.generatedMap[x - 1][y];
            return node;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    private Node2 getBottom(int x, int y) {
        try {
            Node2 node = this.generatedMap[x + 1][y];
            return node;
        } catch (ArrayIndexOutOfBoundsException e) {
            return null;
        }
    }

    private int autotileMap(int x, int y) {
        boolean left, right, top, bottom;
        left = right = top = bottom = false;
        Node2 node;
        if ((node = getRight(x, y)) != null) {
            if (node.getValue() == 0)
                right = true;
        }

        if ((node = getLeft(x, y)) != null) {
            if (node.getValue() == 0)
                left = true;
        }

        if ((node = getTop(x, y)) != null) {
            if (node.getValue() == 0)
                top = true;
        }

        if ((node = getBottom(x, y)) != null) {
            if (node.getValue() == 0)
                bottom = true;
        }
        if (this.generatedMap[x][y].getValue() == 1) {
            // if (right && left && bottom && top)
            // return GRASS_FULL;
            return ROCK_FULL;
        }
        if (this.generatedMap[x][y].getValue() == 0) {
            // CASE WITH OBSTACLES
            // CENTRE WITH OBSTACLES
            if (x > 0 && y < MAP_COLS - 1) {

                // SPECIAL CASE : 4 OBSTACLES
                if (!right && !left && !bottom && !top)
                    return ROCK_BOUNDED;

                // SPECIAL CASE : 3 OBSTACLES
                if (right && !left && !bottom && !top)
                    return ROCK_BOUNDED_RIGHT;
                if (!right && left && !bottom && !top)
                    return ROCK_BOUNDED_LEFT;
                if (!right && !left && bottom && !top)
                    return ROCK_BOUNDED_BOTTOM;
                if (!right && !left && !bottom && top)
                    return ROCK_BOUNDED_TOP;

                // SPECIAL CASE : 2 OBSTACLES
                if (right && left && !bottom && !top)
                    return BOUNDED_TOP_BOTTOM;
                if (!right && !left && bottom && top)
                    return BOUNDED_LEFT_RIGHT;
                // CASE : 2 OBSTACLES
                if (right && !left && bottom && !top)
                    return ROCK_BOTTOM_RIGHT;
                if (!right && left && bottom && !top)
                    return ROCK_BOTTOM_LEFT;
                if (right && !left && !bottom && top)
                    return ROCK_TOP_RIGHT;
                if (!right && left && !bottom && top)
                    return ROCK_TOP_LEFT;

                // CASE : 1 OBSTACLE
                if (right && left && bottom && !top)
                    return ROCK_BOTTOM;
                if (right && left && !bottom && top)
                    return ROCK_TOP;
                if (right && !left && bottom && top)
                    return ROCK_RIGHT;
                if (!right && left && bottom && top)
                    return ROCK_LEFT;

            }

            // CASE: Center 0/0/0/0
            if (right && left && bottom && top)
                return GRASS_FULL;

            // CASE: Edges 0/0/0
            if (y == 0) {
                if (top && right && bottom)
                    return GRASS_FULL;
                if (top && right && !bottom)
                    return ROCK_BOTTOM;
                if (top && !right && bottom)
                    return ROCK_RIGHT;
                if (top && !right && !bottom)
                    return ROCK_BOTTOM_RIGHT;
                if (!top && right && bottom)
                    return ROCK_TOP;
                // Special Case
                if (!top && right && !bottom)
                    return BOUNDED_TOP_BOTTOM;
                if (!top && !right && bottom)
                    return BOUNDED_LEFT_RIGHT;
                // Special Case
                if (!top && !right && !bottom)
                    return ROCK_BOUNDED;
            }
            if (y == MAP_COLS - 1) {
                if (top && left && bottom)
                    return GRASS_FULL;
                if (top && left && !bottom)
                    return ROCK_BOTTOM;
                if (top && !left && bottom)
                    return ROCK_LEFT;
                if (top && !left && !bottom)
                    return ROCK_BOTTOM_LEFT;
                if (!top && left && bottom)
                    return ROCK_TOP;
                // Special Case
                if (!top && left && !bottom)
                    return BOUNDED_TOP_BOTTOM;
                if (!top && !left && bottom)
                    return ROCK_TOP_LEFT;
                // Special Case
                if (!top && !left && !bottom)
                    return ROCK_BOUNDED;
            }
            if (x == 0) {
                if (bottom && left && right)
                    return GRASS_FULL;
                if (bottom && left && !right)
                    return ROCK_RIGHT;
                if (bottom && !left && right)
                    return ROCK_LEFT;
                // Special Case
                if (bottom && !left && !right)
                    return BOUNDED_LEFT_RIGHT;
                if (!bottom && left && right)
                    return ROCK_BOTTOM;
                if (!bottom && left && !right)
                    return ROCK_BOTTOM_RIGHT;
                if (!bottom && !left && right)
                    return ROCK_BOTTOM_LEFT;
                // Special Case
                if (!bottom && !left && !right)
                    return ROCK_BOUNDED;
            }
            if (x == MAP_ROWS - 1) {
                if (top && left && right)
                    return GRASS_FULL;
                if (top && left && !right)
                    return ROCK_RIGHT;
                if (top && !left && right)
                    return ROCK_LEFT;
                // Special Case
                if (top && !left && !right)
                    return ROCK_FULL;
                if (!top && left && right)
                    return ROCK_TOP;
                if (!top && left && !right)
                    return ROCK_TOP_RIGHT;
                if (!top && !left && right)
                    return ROCK_TOP_LEFT;
                // Special Case
                if (!top && !left && !right)
                    return ROCK_BOUNDED;
            }

            // CASE: Corners 0/0
            if (x == 0 && y == 0) {
                if (right && bottom)
                    return GRASS_FULL;
                if (right && !bottom)
                    return ROCK_BOTTOM;
                if (!right && bottom)
                    return ROCK_RIGHT;
                if (!right && !bottom)
                    return ROCK_BOTTOM_RIGHT;
            }
            if (x == 0 && y == MAP_COLS - 1) {
                if (left && bottom)
                    return GRASS_FULL;
                if (left && !bottom)
                    return ROCK_BOTTOM;
                if (!left && bottom)
                    return ROCK_LEFT;
                if (!left && !bottom)
                    return ROCK_BOTTOM_LEFT;
            }
            if (x == MAP_ROWS - 1 && y == 0) {
                if (right && top)
                    return GRASS_FULL;
                if (right && !top)
                    return ROCK_TOP;
                if (!right && top)
                    return ROCK_RIGHT;
                if (!right && !top)
                    return ROCK_TOP_RIGHT;
            }
            if (x == MAP_ROWS - 1 && y == MAP_COLS - 1) {
                if (left && top)
                    return GRASS_FULL;
                if (left && !top)
                    return ROCK_TOP;
                if (!left && top)
                    return ROCK_LEFT;
                if (!left && !top)
                    return ROCK_TOP_LEFT;
            }
        }

        return GRASS_FULL;
    }

    private int pickTile(int row, int col) {
        float value = this.noiseMap[row][col];
        if (value == -1)
            return 1;
        if (value <= 0.45f)
            return 1;
        if (value <= 1.0f)
            return 0;
        return 0;
    }

    public TiledMap generateMap() {
        this.tilesTexture = new Texture(this.filename);
        final TextureRegion[][] splitTiles = TextureRegion.split(this.tilesTexture, tileSize, tileSize);

        // Create tileset
        this.tileSet = new TiledMapTileSet();
        int tid = 0;
        for (int i = 0; i < splitTiles.length; i++) {
            for (int j = 0; j < splitTiles[i].length; j++) {
                final StaticTiledMapTile tile = new StaticTiledMapTile(splitTiles[i][j]);
                tile.setId(tid++);
                this.tileSet.putTile(tile.getId(), tile);
            }
        }

        // Create an empty map
        this.map = new TiledMap();
        this.baseLayer = new TiledMapTileLayer(MAP_WIDTH, MAP_HEIGHT, tileSize, tileSize);
        this.obstacleLayer = new TiledMapTileLayer(MAP_WIDTH, MAP_HEIGHT, tileSize, tileSize);
        this.wallLayer = new TiledMapTileLayer(MAP_WIDTH, MAP_HEIGHT, tileSize, tileSize);
        this.map.getLayers().add(wallLayer);
        this.map.getLayers().add(obstacleLayer);
        this.map.getLayers().add(baseLayer);
        final Array<Texture> textures = Array.with(this.tilesTexture);
        this.map.setOwnedResources(textures);

        for (int row = 0; row < MAP_ROWS; row++) {
            for (int col = 0; col < MAP_COLS; col++) {
                // Pick next tile
                final int tileId = autotileMap(row, col);
                final TiledMapTileLayer.Cell cell = new TiledMapTileLayer.Cell();
                cell.setTile(this.tileSet.getTile(tileId));
                switch (tileId) {
                    case 1:
                    case 2:
                    case 3:
                    case 4:
                    case 5:
                    case 6:
                    case 7:
                    case 12:
                    case 13:
                    case 14:
                    case 15:
                    case 20:
                    case 21:
                    case 22:
                    case 23:
                        this.baseLayer.setCell(col, row, cell);
                        break;

                    case 0:
                    case 47:
                        this.solid_objects.add(new Vector2(col * this.tileSize, row * this.tileSize));
                        this.obstacleLayer.setCell(col, row, cell);
                        break;
                    default:
                        break;
                }
            }
        }

        return this.map;
    }

    public TiledMapTileLayer getTiledMapTileLayer(int id) {
        if (id == 0)
            return this.wallLayer;
        else if (id == 1)
            return this.obstacleLayer;
        else if (id == 2)
            return this.baseLayer;
        return null;
    }

    public Array<Vector2> getSolidObjects() {
        return this.solid_objects;
    }
}
